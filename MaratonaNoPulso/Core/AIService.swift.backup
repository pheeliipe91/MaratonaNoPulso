import Foundation
import Combine

// MARK: - Estruturas da "Science Engine"
struct WeekBlueprint: Codable {
    let focus: String
    let sessions: [SessionBlueprint]
}

struct SessionBlueprint: Codable {
    let day: String
    let type: String
    let targetDistanceKm: Double
    let targetDurationMin: Int
    let intensityConstraints: String
}

// MARK: - Estrutura da An√°lise P√≥s-Treino
struct PostWorkoutAnalysis: Codable {
    let analysisSummary: String
    let recoveryScore: String
    let suggestedAction: String
    let coachComment: String
}

class AIService: ObservableObject {
    // MARK: - Outputs
    @Published var suggestedWorkouts: [AIWorkoutPlan] = []
    @Published var suggestedRoadmap: [CyclePhase] = []
    @Published var generatedSegments: [WorkoutSegment]?
    
    // NOVO: Resultado da an√°lise p√≥s-treino
    @Published var postWorkoutAnalysis: PostWorkoutAnalysis?
    
    // MARK: - Estado
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    
    private let openAIAPIKey = Secrets.openAIAPIKey
    private let endpoint = "https://api.openai.com/v1/chat/completions"
    
    // Armazena assinaturas locais para checagem p√≥s-IA
    private var localExistingSignatures: Set<WorkoutSignature> = []

    // MARK: - 1. GERA√á√ÉO DE SEMANA (COM CONTEXTO DE SA√öDE)
    func generateWeekPlan(for user: AIUserProfile, healthContext: String, instruction: String? = nil, existingPlans: [DailyPlan] = []) {
        guard let _ = URL(string: endpoint) else { return }
        
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil
            self.suggestedWorkouts = []
            self.suggestedRoadmap = []
        }
        
        // 1. CARREGAR ASSINATURAS EXISTENTES (Blindagem N√≠vel C√≥digo)
        self.localExistingSignatures = Set(existingPlans.map { $0.signature })
        
        // 2. CAMADA CIENT√çFICA: Calcular Carga e Estrutura
        let blueprint = calculateWeekBlueprint(for: user)
        let blueprintJson = blueprint.safeJsonString // Usa nosso helper seguro
        
        // 3. CAMADA DE CONTEXTO PARA IA
        let existingTitles = existingPlans.map { $0.title }.joined(separator: ", ")
        
        let systemPersona = """
        Voc√™ √© o 'Coach Cient√≠fico' (Expert em Fisiologia e HealthKit).
        Sua fun√ß√£o √© detalhar um blueprint de treino, adaptando a narrativa ao hist√≥rico recente de sa√∫de do atleta.
        
        REGRAS DE OURO (HARD CONSTRAINTS):
        1. OBEDE√áA O BLUEPRINT: Use EXATAMENTE os valores de 'targetDistanceKm' e 'targetDurationMin'. N√£o altere o volume.
        2. ANALISE A SA√öDE: Leia o 'CONTEXTO DE SA√öDE' abaixo. Se o atleta correu muito ontem, mencione recupera√ß√£o no 'workoutReasoning'.
        3. CRIATIVIDADE CONTROLADA: Crie t√≠tulos √∫nicos (nunca repita os listados).
        4. ANTI-ALUCINA√á√ÉO: Siga a 'intensityConstraints' do blueprint rigorosamente.
        """
        
        let prompt = """
        DADOS DO ATLETA:
        - N√≠vel: \(user.experienceLevel)
        - Objetivo: "\(instruction ?? user.goal)"
        
        CONTEXTO DE SA√öDE (HEALTHKIT RECENTE):
        \(healthContext)
        
        BLUEPRINT CIENT√çFICO (ESTRUTURA IMUT√ÅVEL):
        \(blueprintJson)
        
        T√çTULOS J√Å USADOS (PROIBIDO REPETIR):
        [\(existingTitles)]
        
        TAREFA:
        Para cada sess√£o do blueprint, gere um objeto 'AIWorkoutPlan'.
        - Preencha 'distance' e 'duration' com os valores exatos do blueprint.
        - No campo 'workoutReasoning', explique a escolha baseada no hist√≥rico de sa√∫de (ex: "Como voc√™ correu X km ontem...").
        
        SA√çDA JSON:
        {
            "roadmap": [ { "phaseName": "Base", "duration": "Semana Atual", "focus": "\(blueprint.focus)" } ],
            "workouts": [
                {
                    "title": "Nome T√©cnico",
                    "suggestedDay": "Copiar do Blueprint",
                    "cyclePhase": "Base",
                    "cycleTarget": "\(user.goal)",
                    "distance": 0.0,
                    "duration": 0,
                    "type": "Running",
                    "rawInstructionText": "Instru√ß√£o completa...",
                    "workoutReasoning": "Justificativa conectada ao HealthKit...",
                    "safetyWarning": "Aviso de seguran√ßa...",
                    "zoneFocus": "Z2/Z4...",
                    "difficultyRating": "Baixa/M√©dia"
                }
            ]
        }
        """
        
        performOpenAIRequest(system: systemPersona, prompt: prompt, maxTokens: 4000) { data in
            self.handleWeekResponse(data: data)
        }
    }
    
    // MARK: - ENGINE CIENT√çFICA (L√≥gica Swift Pura)
    private func calculateWeekBlueprint(for user: AIUserProfile) -> WeekBlueprint {
        // Regra de Volume Inicial
        var safeVolume: Double
        
        // TRATAMENTO ESPECIAL PARA INICIANTE ZERO KM
        if user.experienceLevel == "Iniciante" && user.currentDistance <= 1.0 {
            safeVolume = 6.0 // Teto r√≠gido para quem est√° saindo do sof√° (ex: 3x 2km)
        } else {
            let baseVolume = user.currentDistance > 0 ? user.currentDistance : 15.0
            safeVolume = min(baseVolume * 1.10, baseVolume + 4.0) // Regra dos 10%
        }
        
        // Distribui√ß√£o
        let days = max(1, user.daysPerWeek)
        let longRunDist = (safeVolume * 0.30).rounded()
        let remainingDist = safeVolume - longRunDist
        let easyDist = (remainingDist / Double(max(1, days - 1))).rounded()
        
        var sessions: [SessionBlueprint] = []
        
        // Sess√£o 1: Longo (Fim de semana)
        // Pace estimado lento para iniciantes (8min/km) vs avan√ßados (5min/km) para calcular dura√ß√£o
        let paceEst = user.experienceLevel == "Iniciante" ? 9.0 : 6.0
        
        sessions.append(SessionBlueprint(
            day: "S√°bado",
            type: "Long Run",
            targetDistanceKm: longRunDist,
            targetDurationMin: Int(longRunDist * paceEst),
            intensityConstraints: "Z2 Strict / Aer√≥bico"
        ))
        
        // Sess√µes Extras
        if days > 1 {
            for i in 0..<(days - 1) {
                let isQualityDay = (user.experienceLevel != "Iniciante" && i == 0)
                let type = isQualityDay ? "Intervals" : "Easy Run"
                
                // CONSTRAINT DE INICIANTE: WALK/RUN OBRIGAT√ìRIO
                let constraint = (user.experienceLevel == "Iniciante") ? "Walk/Run Method (Galloway)" : (isQualityDay ? "Threshold Z4" : "Recovery Z1")
                
                sessions.append(SessionBlueprint(
                    day: (i == 0) ? "Ter√ßa" : "Quinta",
                    type: type,
                    targetDistanceKm: easyDist,
                    targetDurationMin: Int(easyDist * paceEst),
                    intensityConstraints: constraint
                ))
            }
        }
        
        return WeekBlueprint(focus: "Constru√ß√£o de Base", sessions: sessions)
    }
    
    // MARK: - 2. GERA√á√ÉO MICRO (CORRIGIDO E ROBUSTO)
    func generateDetailedSegments(for instruction: String, title: String, phase: String, user: AIUserProfile) {
        guard let _ = URL(string: endpoint) else { return }
        
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil
            self.generatedSegments = nil
        }
        
        // üî• DEFINI√á√ÉO ESTRITA DO SCHEMA JSON PARA A IA SEGUIR
        let strictSchema = """
        {
            "segments": [
                {
                    "role": "String (Obrigat√≥rio: 'warmup', 'work', 'recovery', ou 'cooldown')",
                    "goalType": "String (Obrigat√≥rio: 'time', 'distance', ou 'open')",
                    "durationMinutes": "Double (Opcional: Apenas se goalType='time'. Ex: 10.0)",
                    "distanceKm": "Double (Opcional: Apenas se goalType='distance'. Ex: 1.5)",
                    "intensity": "String (Ex: 'Z2', 'Z4', 'Leve', 'Forte')",
                    "reps": "Int (Opcional: Se for uma repeti√ß√£o, ex: 1)",
                    "targetPaceMin": "String (Opcional: Ex: '4:30')",
                    "targetPaceMax": "String (Opcional: Ex: '5:00')"
                }
            ]
        }
        """
        
        let systemPersona = """
        Voc√™ √© uma Engine de Estrutura√ß√£o de Treinos para Apple Watch.
        Sua √∫nica fun√ß√£o √© converter texto descritivo em um ARRAY JSON estrito que o Swift possa decodificar.
        
        REGRAS CR√çTICAS:
        1. Use EXATAMENTE as chaves do schema JSON abaixo. N√£o invente campos.
        2. 'role' deve ser APENAS: "warmup", "work", "recovery", "cooldown".
        3. 'goalType' deve ser APENAS: "time", "distance", "open".
        4. Converta todos os n√∫meros para Double ou Int conforme o schema.
        5. Se a instru√ß√£o for "3x 1km", crie 3 pares de segmentos (work + recovery) ou use o campo 'reps' se o app suportar blocos (neste caso, gere os segmentos linearmente explodidos para garantir compatibilidade).
        
        SCHEMA OBRIGAT√ìRIO:
        \(strictSchema)
        """
        
        let prompt = """
        TREINO: "\(title)"
        FASE: \(phase)
        INSTRU√á√ÉO COMPLETA: "\(instruction)"
        
        TAREFA: Quebre este treino em segmentos l√≥gicos (Aquecimento -> Parte Principal -> Desaquecimento).
        """
        
        performOpenAIRequest(system: systemPersona, prompt: prompt, maxTokens: 2500) { data in
            self.handleMicroResponse(data: data)
        }
    }
    
    // MARK: - 3. INTELIG√äNCIA P√ìS-TREINO (NOVO)
    func analyzePostWorkout(workoutData: String, userFeedback: String, painStatus: String) {
        guard let _ = URL(string: endpoint) else { return }
        
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil
            self.postWorkoutAnalysis = nil // Limpa an√°lise anterior
        }
        
        let systemPersona = """
        Voc√™ √© um Fisiologista do Esporte analisando o p√≥s-treino de um atleta.
        Seu objetivo √© cruzar os dados brutos do treino com o feedback subjetivo (sensa√ß√£o/dor) para decidir os pr√≥ximos passos.
        """
        
        let prompt = """
        DADOS DO TREINO REALIZADO (HealthKit):
        \(workoutData)
        
        FEEDBACK DO ATLETA:
        - Sensa√ß√£o (RPE): \(userFeedback)
        - Status de Dor/Les√£o: \(painStatus)
        
        AN√ÅLISE NECESS√ÅRIA:
        1. O atleta cumpriu o objetivo?
        2. H√° sinais de overtraining ou les√£o?
        3. O plano futuro precisa de ajuste? (Ex: Se houve dor, sugerir descanso amanh√£).
        
        SA√çDA JSON:
        {
            "analysisSummary": "Texto curto e direto analisando a performance.",
            "recoveryScore": "0 a 100 (Baseado no esfor√ßo)",
            "suggestedAction": "Manter Plano" ou "Alterar para Recupera√ß√£o" ou "Descanso Total",
            "coachComment": "Coment√°rio motivacional ou t√©cnico curto."
        }
        """
        
        performOpenAIRequest(system: systemPersona, prompt: prompt, maxTokens: 1000) { data in
            self.handlePostWorkoutResponse(data: data)
        }
    }

    // MARK: - Helpers de API e Parsing
    
    private func performOpenAIRequest(system: String, prompt: String, maxTokens: Int, completion: @escaping (Data) -> Void) {
        guard let url = URL(string: endpoint) else { reportError("URL inv√°lida."); return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("Bearer \(openAIAPIKey)", forHTTPHeaderField: "Authorization")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 60
        
        let requestBody: [String: Any] = [
            "model": "gpt-4o",
            "messages": [["role": "system", "content": system], ["role": "user", "content": prompt]],
            "temperature": 0.5,
            "max_tokens": maxTokens,
            "response_format": ["type": "json_object"]
        ]
        
        do { request.httpBody = try JSONSerialization.data(withJSONObject: requestBody) } catch {}
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async { self.isLoading = false }
            if let error = error { self.reportError("Erro: \(error.localizedDescription)"); return }
            guard let data = data else { return }
            completion(data)
        }.resume()
    }
    
    // MARK: - Response Handlers
    
    private func handleWeekResponse(data: Data) {
        struct ResponseWrapper: Decodable {
            let roadmap: [CyclePhase]?
            let workouts: [AIWorkoutPlan]
        }
        struct OpenAIResponse: Decodable {
            struct Choice: Decodable {
                struct Message: Decodable {
                    let content: String
                }
                let message: Message
            }
            let choices: [Choice]
        }
        
        do {
            let decoded = try JSONDecoder().decode(OpenAIResponse.self, from: data)
            guard let content = decoded.choices.first?.message.content else {
                reportError("Resposta vazia da API")
                return
            }
            
            // Limpa poss√≠veis artefatos de markdown
            let cleanJson = content
                .replacingOccurrences(of: "```json", with: "")
                .replacingOccurrences(of: "```", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            guard let jsonData = cleanJson.data(using: .utf8) else {
                reportError("Falha ao converter JSON")
                return
            }
            
            let wrapper = try JSONDecoder().decode(ResponseWrapper.self, from: jsonData)
            
            // FILTRO ANTI-DUPLICA√á√ÉO (Blindagem N√≠vel C√≥digo)
            let uniqueWorkouts = wrapper.workouts.filter { workout in
                !self.localExistingSignatures.contains(workout.signature)
            }
            
            DispatchQueue.main.async {
                self.suggestedRoadmap = wrapper.roadmap ?? []
                self.suggestedWorkouts = uniqueWorkouts
                
                if uniqueWorkouts.count < wrapper.workouts.count {
                    print("‚ö†Ô∏è FILTRO ATIVO: \(wrapper.workouts.count - uniqueWorkouts.count) treinos duplicados removidos")
                }
            }
            
        } catch {
            reportError("Erro ao decodificar: \(error.localizedDescription)")
        }
    }
    
    private func handleMicroResponse(data: Data) {
        struct SegmentWrapper: Decodable {
            let segments: [WorkoutSegment]
        }
        struct OpenAIResponse: Decodable {
            struct Choice: Decodable {
                struct Message: Decodable {
                    let content: String
                }
                let message: Message
            }
            let choices: [Choice]
        }
        
        do {
            let decoded = try JSONDecoder().decode(OpenAIResponse.self, from: data)
            guard let content = decoded.choices.first?.message.content else {
                reportError("Resposta vazia da API")
                return
            }
            
            // Limpa poss√≠veis artefatos de markdown
            let cleanJson = content
                .replacingOccurrences(of: "```json", with: "")
                .replacingOccurrences(of: "```", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            guard let jsonData = cleanJson.data(using: .utf8) else {
                reportError("Falha ao converter JSON dos segmentos")
                return
            }
            
            let wrapper = try JSONDecoder().decode(SegmentWrapper.self, from: jsonData)
            
            DispatchQueue.main.async {
                self.generatedSegments = wrapper.segments
                print("‚úÖ \(wrapper.segments.count) segmentos gerados com sucesso")
            }
            
        } catch {
            reportError("Erro ao decodificar segmentos: \(error.localizedDescription)")
        }
    }
    
    private func handlePostWorkoutResponse(data: Data) {
        struct OpenAIResponse: Decodable {
            struct Choice: Decodable {
                struct Message: Decodable {
                    let content: String
                }
                let message: Message
            }
            let choices: [Choice]
        }
        
        do {
            let decoded = try JSONDecoder().decode(OpenAIResponse.self, from: data)
            guard let content = decoded.choices.first?.message.content else {
                reportError("Resposta vazia da API")
                return
            }
            
            // Limpa poss√≠veis artefatos de markdown
            let cleanJson = content
                .replacingOccurrences(of: "```json", with: "")
                .replacingOccurrences(of: "```", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            guard let jsonData = cleanJson.data(using: .utf8) else {
                reportError("Falha ao converter JSON da an√°lise")
                return
            }
            
            let analysis = try JSONDecoder().decode(PostWorkoutAnalysis.self, from: jsonData)
            
            DispatchQueue.main.async {
                self.postWorkoutAnalysis = analysis
                print("‚úÖ An√°lise p√≥s-treino conclu√≠da")
            }
            
        } catch {
            reportError("Erro ao decodificar an√°lise: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Error Handling
    
    private func reportError(_ message: String) {
        DispatchQueue.main.async {
            self.errorMessage = message
            self.isLoading = false
            print("‚ùå AIService Error: \(message)")
        }
    }
}

// MARK: - Extensions Auxiliares

extension WeekBlueprint {
    var safeJsonString: String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        guard let data = try? encoder.encode(self),
              let jsonString = String(data: data, encoding: .utf8) else {
            return "{\"error\": \"Falha ao serializar blueprint\"}"
        }
        
        return jsonString
    }
}

// MARK: - Estruturas Auxiliares Necess√°rias
// (Adicione essas se ainda n√£o existirem no projeto)

struct AIWorkoutPlan: Codable, Identifiable {
    let id = UUID()
    let title: String
    let suggestedDay: String
    let cyclePhase: String
    let cycleTarget: String
    let distance: Double
    let duration: Int
    let type: String
    let rawInstructionText: String
    let workoutReasoning: String
    let safetyWarning: String
    let zoneFocus: String
    let difficultyRating: String
    
    var signature: WorkoutSignature {
        WorkoutSignature(
            day: suggestedDay,
            distance: distance,
            duration: duration
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case title, suggestedDay, cyclePhase, cycleTarget
        case distance, duration, type
        case rawInstructionText, workoutReasoning
        case safetyWarning, zoneFocus, difficultyRating
    }
}

struct WorkoutSignature: Hashable, Codable {
    let day: String
    let distance: Double
    let duration: Int
}

struct CyclePhase: Codable, Identifiable {
    let id = UUID()
    let phaseName: String
    let duration: String
    let focus: String
    
    enum CodingKeys: String, CodingKey {
        case phaseName, duration, focus
    }
}

struct WorkoutSegment: Codable, Identifiable {
    let id = UUID()
    let role: String // warmup, work, recovery, cooldown
    let goalType: String // time, distance, open
    let durationMinutes: Double?
    let distanceKm: Double?
    let intensity: String
    let reps: Int?
    let targetPaceMin: String?
    let targetPaceMax: String?
    
    enum CodingKeys: String, CodingKey {
        case role, goalType, durationMinutes, distanceKm
        case intensity, reps, targetPaceMin, targetPaceMax
    }
}

struct AIUserProfile {
    let experienceLevel: String // "Iniciante", "Intermedi√°rio", "Avan√ßado"
    let goal: String
    let currentDistance: Double // km por semana atual
    let daysPerWeek: Int
}

struct DailyPlan {
    let title: String
    let signature: WorkoutSignature
}
